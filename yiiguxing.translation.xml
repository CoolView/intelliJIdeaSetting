<application>
  <component name="AppStorage">
    <histories>
      <item value="// 7. Prefer ObjectReader/ObjectWriter over ObjectMapper // Although the main reason to prefer these objects is thread-safety // (and thus correctness),there may be performance benefits as well // 8.When reading a root-level sequence of POJOs, // readValues() method of ObjectReader can be much more efficient // than doing explicit iteration using ObjectMapper.readValue() method." />
      <item value="performance" />
      <item value="ROUND DOWN" />
      <item value="approved" />
      <item value="Public" />
      <item value="Internal" />
      <item value="constructor" />
      <item value="Gross weight" />
      <item value="special" />
      <item value="VALIDATION CODE" />
      <item value="PARAM FAIL CODE" />
      <item value="custom" />
      <item value="RESULT" />
      <item value="Base exception of all Bean Validation &quot;unexpected&quot; problems." />
      <item value="the maximum time to wait in milliseconds." />
      <item value="report" />
      <item value="Selective" />
      <item value="cascaded" />
      <item value="validate" />
      <item value="Cannot resolve constructor with specified argument types" />
      <item value="The notion of present is defined relatively to the type on which the constraint is * used." />
      <item value="Ferentschik" />
      <item value="maximum number of fractional digits accepted for this number" />
      <item value="maximum number of integral digits accepted for this number" />
      <item value="elements are considered valid." />
      <item value="mail Port" />
      <item value="REDIS RESOURCE" />
      <item value="SYSTEM PROPERTY REDIS PROPERTIES FILENAME" />
      <item value="Only one AsyncAnnotationBeanPostProcessor may exist within the context." />
      <item value="Keep-alive time in seconds. Inactive threads that have been created beyond the core size will timeout after the specified number of seconds elapse. If the executor has an unbounded queue capacity and a size range represented as 0-n, then the core threads will also be configured to timeout when inactive. Otherwise, core threads will not ever timeout." />
      <item value="Queue capacity for the ThreadPoolTaskExecutor. If not specified, the default will be Integer.MAX_VALUE (i.e. unbounded)." />
      <item value="The size of the executor's thread pool as either a single value or a range (e.g. 5-10). If no bounded queue-capacity value is provided, then a max value has no effect unless the range is specified as 0-n. In that case, the core pool will have a size of n, but the 'allowCoreThreadTimeout' flag will be set to true. If a queue-capacity is provided, then the lower bound of a range will map to the core size and the upper bound will map to the max size. If this attribute is not provided, the default core size will be 1, and the default max size will be Integer.MAX_VALUE (i.e. unbounded)." />
      <item value="The bean name for the generated ThreadPoolTaskExecutor instance. This value will also be used as the thread name prefix which is why it is required even when defining the executor as an inner bean: The executor won't be directly accessible then but will nevertheless use the specified id as the thread name prefix of the threads that it manages. In the case of multiple task:executors, as of Spring 3.1.2 this value may be used to qualify which executor should handle a given @Async method, e.g. @Async(&quot;executorId&quot;). See the Javadoc for the #value attribute of Spring's @Async annotation for details." />
      <item value="Should annotated beans be proxied using Spring's AOP framework, or should they rather be weaved with an AspectJ async execution aspect? AspectJ weaving requires spring-aspects.jar on the classpath, as well as load-time weaving (or compile-time weaving) enabled. Note: The weaving-based aspect requires the @Async annotation to be defined on the concrete class. Annotations in interfaces will not work in that case (they will rather only work with interface-based proxies)!" />
      <item value="Specifies the org.springframework.scheduling.TaskScheduler or java.util.ScheduledExecutorService instance to use when invoking scheduled methods. If no reference is provided, a TaskScheduler backed by a single thread scheduled executor will be used." />
      <item value="Queue capacity for the ThreadPoolTaskExecutor. If not specified, the default will be Integer.MAX_VALUE (i.e. unbounded)" />
      <item value="annotation Executor" />
      <item value="Async" />
      <item value="Rest" />
      <item value="Assert" />
      <item value="Origin bean whose properties are retrieved" />
      <item value="Destination bean whose properties are modified" />
      <item value="LANG-530 - need to make sure 'ZZ' output doesn't get passed to SimpleDateFormat" />
      <item value="the date format patterns to use, see SimpleDateFormat, not null" />
      <item value="parse Date" />
      <item value="Exists" />
      <item value="trim" />
      <item value="Delivery" />
      <item value="Unterminated string literal" />
      <item value="Tried to send an out-of-range integer as a 2-byte value" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="190" />
        <entry key="ENGLISH" value="191" />
        <entry key="FRENCH" value="2" />
        <entry key="SPANISH" value="2" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="translateDocumentation" value="false" />
  </component>
</application>